import { watch } from "fs";
import path from "node:path";
import fs from "node:fs";
import { Glob } from "bun";

// User's project directory (cwd)
const projectDir = process.cwd();
const vegabaseDir = path.join(projectDir, ".vegabase");

// Types for route manifest
interface RouteConfig {
  path: string;
  component: string;
  cacheTime: number;
  preload: "intent" | "viewport" | "render";
}

interface RouteManifest {
  version: number;
  routes: RouteConfig[];
}



/**
 * Load route manifest from .vegabase/routes.json
 */
function loadRouteManifest(): RouteManifest {
  const manifestPath = path.join(vegabaseDir, "routes.json");
  if (!fs.existsSync(manifestPath)) {
    console.error("‚ùå Error: .vegabase/routes.json not found");
    console.error("   Run 'python routes.py' to generate the route manifest.");
    process.exit(1);
  }
  const content = fs.readFileSync(manifestPath, "utf-8");
  return JSON.parse(content) as RouteManifest;
}

/**
 * Generate route variable name from component path
 */
function toRouteVarName(component: string): string {
  // "Tasks/Index" -> "tasksIndexRoute"
  return (
    component
      .replace(/\//g, "_")
      .replace(/([A-Z])/g, (_, c, i) => (i === 0 ? c.toLowerCase() : c))
      .replace(/_([a-z])/g, (_, c) => c.toUpperCase()) + "Route"
  );
}

/**
 * Generate TanStack Router route tree from manifest
 */
function generateRouteTree(manifest: RouteManifest): string {
  const routes = manifest.routes;

  // Generate direct component imports (not lazy for SSR compatibility)
  const componentImports = routes
    .map((route) => {
      const varName = route.component.replace(/\//g, "_");
      return `import ${varName} from '${projectDir}/frontend/pages/${route.component}';`;
    })
    .join("\n");

  // Generate route factory functions (they need a parent route reference)
  const routeFactories = routes
    .map((route) => {
      const varName = toRouteVarName(route.component);
      const factoryName = `create${varName.charAt(0).toUpperCase() + varName.slice(1)}`;
      const componentVar = route.component.replace(/\//g, "_");
      const staleTime = route.cacheTime > 0 ? route.cacheTime * 1000 : 0;

      // Handle path parameters for fetch URL
      const fetchPath = route.path.includes("$")
        ? `\`${route.path.replace(/\$(\w+)/g, "${params.$1}")}\``
        : `'${route.path}'`;

      return `
function ${factoryName}(parentRoute: any) {
  return createRoute({
    getParentRoute: () => parentRoute,
    path: '${route.path}',
    component: function ${componentVar}Wrapper() {
      const data = useLoaderData({ from: '${route.path}' });
      return <${componentVar} {...data} />;
    },
    loader: async ({ context, params }) => {
      // During SSR, use ssrProps that were set before render
      if (ssrProps) {
        const props = ssrProps;
        ssrProps = null;  // Clear after use
        return props;
      }
      // During client-side navigation, fetch from backend
      const res = await fetch(${fetchPath}, {
        headers: { 'X-Vegabase': 'true', 'Accept': 'application/json' },
        credentials: 'include'
      });
      const data = await res.json();
      return data.props;
    },
    ${staleTime > 0 ? `staleTime: ${staleTime},` : ""}
  });
}`.trim();
    })
    .join("\n\n");

  // Generate route factory names for building trees
  const routeFactoryNames = routes.map((r) => {
    const varName = toRouteVarName(r.component);
    return `create${varName.charAt(0).toUpperCase() + varName.slice(1)}`;
  });
  const routeFactoryCalls = (parentVar: string) =>
    routeFactoryNames.map((fn) => `${fn}(${parentVar})`).join(",\n  ");

  const defaultPreload = routes[0]?.preload || "intent";

  return `// Auto-generated by vegabase - DO NOT EDIT
import {
  createRouter as createTanStackRouter,
  createRoute,
  createRootRoute,
  useLoaderData,
  Outlet,
  Scripts,
} from '@tanstack/react-router';

// Import page components
${componentImports}

// SSR props - set before render, used by loaders
let ssrProps: any = null;
// SSR mode - set before render to control script injection
let ssrMode: string = 'ssr';

export function setSSRProps(props: any) {
  ssrProps = props;
}

export function setSSRMode(mode: string) {
  ssrMode = mode;
}

// Root component for SSR - renders full HTML document (required for proper SSR hydration)
function SSRRootComponent() {
  // In static mode, don't include any JavaScript
  const includeScripts = ssrMode !== 'static';

  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>App</title>
        <link rel="stylesheet" href="/static/dist/client.css" />
      </head>
      <body>
        <div id="app">
          <Outlet />
        </div>
        {/* Scripts component injects SSR dehydration data - skip for static */}
        {includeScripts && <Scripts />}
        {includeScripts && <script type="module" src="/static/dist/client.js"></script>}
      </body>
    </html>
  );
}

// Root component for client-only mode - just renders Outlet (HTML shell provides the document)
function ClientRootComponent() {
  return <Outlet />;
}

// Root route for SSR (full HTML document)
const ssrRootRoute = createRootRoute({
  component: SSRRootComponent,
});

// Root route for client-only mode (just app content)
const clientRootRoute = createRootRoute({
  component: ClientRootComponent,
});

${routeFactories}

// Build route trees by calling factories with the appropriate parent
const ssrRouteTree = ssrRootRoute.addChildren([
  ${routeFactoryCalls("ssrRootRoute")}
]);

const clientRouteTree = clientRootRoute.addChildren([
  ${routeFactoryCalls("clientRootRoute")}
]);

// Factory function for SSR router (used during SSR and hydration)
export function createRouter() {
  return createTanStackRouter({
    routeTree: ssrRouteTree,
    defaultPreload: '${defaultPreload}',
    defaultStaleTime: 0,
  });
}

// Factory function for client-only router (used when mounting into #app)
export function createClientRouter() {
  return createTanStackRouter({
    routeTree: clientRouteTree,
    defaultPreload: '${defaultPreload}',
    defaultStaleTime: 0,
  });
}

// Register router for type inference
declare module '@tanstack/react-router' {
  interface Register {
    router: ReturnType<typeof createRouter>;
  }
}
`;
}

function generateTanStackClientEntry(): string {
  // Note: CSS is built separately to avoid runtime CSS injection
  return `
import { hydrateRoot, createRoot } from 'react-dom/client';
import { RouterClient } from '@tanstack/react-router/ssr/client';
import { RouterProvider } from '@tanstack/react-router';
import { createRouter, createClientRouter } from './routeTree.gen';

// Hot Reload Logic for Development
if (typeof window !== 'undefined' && window.location.hostname === "localhost") {
    const ws = new WebSocket("ws://localhost:${process.env.PORT || 3001}/ws");
  ws.onmessage = (event) => {
    if (event.data === "reload") {
      console.log("‚ôªÔ∏è Refreshing...");
      window.location.reload();
    }
  };
}

// Check if SSR dehydration data exists (set by Scripts component via streaming SSR)
if (typeof window !== 'undefined' && (window as any).$_TSR) {
  // SSR mode: Hydrate entire document with RouterClient (streaming SSR)
  console.log("üî• Hydrating SSR page");
  const router = createRouter();
  hydrateRoot(document, <RouterClient router={ router } />);
} else {
  // Client-only mode: Mount into #app using client router
  console.log("üì¶ Client-side render");
  const appElement = document.getElementById('app');
  if (appElement) {
    const clientRouter = createClientRouter();
    createRoot(appElement).render(<RouterProvider router={ clientRouter } />);
  }
}
`.trim();
}

/**
 * Generate TanStack Router SSR entry
 */
function generateTanStackSSREntry(): string {
  return `
import { createRequestHandler, defaultStreamHandler } from '@tanstack/react-router/ssr/server';
import { createRouter, setSSRProps, setSSRMode } from './routeTree.gen';

export default async function render(page: {
  component: string;
  props: any;
  url: string;
  mode?: string;
}) {
  // Set SSR mode and props before rendering
  setSSRMode(page.mode || 'ssr');
  setSSRProps(page.props);

  // Create request for the URL
  const request = new Request(\`http://localhost\${page.url}\`, { method: 'GET' });

  // Use TanStack's SSR handler - this handles dehydration via Scripts component
  const handler = createRequestHandler({ request, createRouter });
  const response = await handler(defaultStreamHandler);

  // Read the streaming response
  const html = await response.text();

  // Return full HTML document (Python should NOT wrap this)
  return { head: [], body: html };
}
`.trim();
}

/**
 * Generate TanStack Router SSR server entry
 */
function generateTanStackSSRServerEntry(): string {
  return `
import render from './ssr.tsx';

const port = Number(process.env.PORT) || 13714;

console.log(\`Starting TanStack Router SSR server on port \${port}...\`);

Bun.serve({
    port,
    async fetch(req) {
        const url = new URL(req.url);

        if (req.method === "GET" && url.pathname === "/health") {
            return Response.json({ status: "OK", timestamp: Date.now() });
        }

        if (req.method === "GET" && url.pathname === "/shutdown") {
            process.exit(0);
        }

        if (req.method === "POST" && url.pathname === "/render") {
            try {
                const page = await req.json();
                const result = await render(page);
                return Response.json(result);
            } catch (error: any) {
                console.error("SSR Error:", error);
                return Response.json({ error: error.message }, { status: 500 });
            }
        }

        return new Response("Not Found", { status: 404 });
    },
});
`.trim();
}



/**
 * Generate all entry files in the user's project
 */
async function generateEntryFiles() {
  // Ensure .vegabase directory exists
  if (!fs.existsSync(vegabaseDir)) {
    fs.mkdirSync(vegabaseDir, { recursive: true });
  }

  const manifest = loadRouteManifest();

  console.log("üì¶ Using TanStack Router");

  const routeTreeCode = generateRouteTree(manifest);
  const clientEntry = generateTanStackClientEntry();
  const ssrEntry = generateTanStackSSREntry();
  const ssrServerEntry = generateTanStackSSRServerEntry();

  fs.writeFileSync(path.join(vegabaseDir, "routeTree.gen.tsx"), routeTreeCode);
  fs.writeFileSync(path.join(vegabaseDir, "client.tsx"), clientEntry);
  fs.writeFileSync(path.join(vegabaseDir, "ssr.tsx"), ssrEntry);
  fs.writeFileSync(path.join(vegabaseDir, "ssr-server.tsx"), ssrServerEntry);

  console.log("üìù Generated TanStack Router files in .vegabase/");
}

// Entry points for TanStack Router
function getEntryPoints() {
  return {
    client: path.join(vegabaseDir, "client.tsx"),
    ssr: path.join(vegabaseDir, "ssr.tsx"),
    ssrServer: path.join(vegabaseDir, "ssr-server.tsx"),
    external: ["react", "react-dom", "@tanstack/react-router"],
  };
}

// ==================== DEV COMMAND ====================
async function dev() {
  await generateEntryFiles();

  const entries = getEntryPoints();

  // Import tailwind plugin from user's project
  const { default: tailwindcss } = await import(
    path.join(projectDir, "node_modules", "bun-plugin-tailwind")
  );

  async function build() {
    // Regenerate files on each build
    await generateEntryFiles();

    console.log("‚ö° Building...");

    // Build CSS separately (prevents runtime CSS injection in client.js)
    await Bun.build({
      entrypoints: [`${projectDir}/frontend/styles.css`],
      outdir: "./static/dist",
      naming: "client.[ext]",
      plugins: [tailwindcss],
    });

    // Bundle Client (no CSS import - uses <link> tag)
    await Bun.build({
      entrypoints: [entries.client],
      outdir: "./static/dist",
      naming: "client.[ext]",
      target: "browser",
      splitting: true,
    });

    // Bundle SSR (Library for Dev Server)
    await Bun.build({
      entrypoints: [entries.ssr],
      outdir: "./.vegabase",
      naming: { entry: "ssr_dev.js" },
      target: "bun",
      external: entries.external,
    });

    console.log("‚úÖ Build complete.");
  }

  await build();

  const server = Bun.serve({
    port: process.env.PORT || 3001,
    async fetch(req, server) {
      const url = new URL(req.url);

      // SSR Render Endpoint
      if (req.method === "POST" && url.pathname === "/render") {
        try {
          const buildPath = `${vegabaseDir}/ssr_dev.js`;
          const { default: render } = await import(buildPath + `?t=${Date.now()}`);
          const page = await req.json();
          const result = await render(page);
          return Response.json(result);
        } catch (error: any) {
          console.error("SSR Error:", error);
          return new Response(JSON.stringify({ error: error.message }), { status: 500 });
        }
      }

      const corsHeaders = {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      };

      if (req.method === "OPTIONS") {
        return new Response(null, { headers: corsHeaders });
      }

      if (url.pathname === "/ws") {
        if (server.upgrade(req)) return;
        return new Response("Upgrade failed", { status: 500 });
      }

      if (url.pathname.endsWith(".js")) {
        const filePath = `./static/dist${url.pathname}`;
        const file = Bun.file(filePath);
        if (await file.exists()) {
          return new Response(file, {
            headers: { ...corsHeaders, "Content-Type": "application/javascript" },
          });
        }
      }

      if (url.pathname === "/client.css") {
        return new Response(Bun.file("./static/dist/client.css"), {
          headers: { ...corsHeaders, "Content-Type": "text/css" },
        });
      }

      return new Response("Not Found", { status: 404, headers: corsHeaders });
    },
    websocket: {
      message() { },
      open(_ws) {
        console.log("Browser connected to Hot Reload");
      },
    },
  });

  console.log(`üëÄ Watcher & Asset Server running on http://localhost:${server.port}`);

  const _watcher = watch("./frontend", { recursive: true }, async (event, filename) => {
    if (filename) {
      await build();
      server.publish("reload", "reload");
    }
  });
}

// ==================== BUILD COMMAND ====================
async function build() {
  await generateEntryFiles();

  const entries = getEntryPoints();

  // Import tailwind plugin from user's project
  const { default: tailwindcss } = await import(
    path.join(projectDir, "node_modules", "bun-plugin-tailwind")
  );

  // Build CSS separately (prevents runtime CSS injection in client.js)
  await Bun.build({
    entrypoints: [`${projectDir}/frontend/styles.css`],
    outdir: "./static/dist",
    naming: "client.[ext]",
    plugins: [tailwindcss],
  });
  console.log("‚úÖ CSS Built");

  // Bundle the Client (no CSS import - uses <link> tag)
  await Bun.build({
    entrypoints: [entries.client],
    outdir: "./static/dist",
    naming: "client.[ext]",
    target: "browser",
    splitting: true,
    minify: true,
  });
  console.log("‚úÖ Client Bundle Built");

  // Bundle the Server (for SSR)
  await Bun.build({
    entrypoints: [entries.ssrServer],
    outdir: "./.vegabase",
    naming: { entry: "ssr.js" },
    target: "bun",
    external: entries.external,
    plugins: [tailwindcss],
  });
  console.log("‚úÖ SSR Bundles Built");
}

// ==================== START COMMAND ====================
async function start() {
  const ssrPath = path.join(vegabaseDir, "ssr.js");

  if (!fs.existsSync(ssrPath)) {
    console.error("‚ùå Error: SSR server bundle not found at .vegabase/ssr.js");
    console.error("   Run 'vegabase build' first to create the production bundle.");
    process.exit(1);
  }

  const port = Number(process.env.PORT) || 13714;

  console.log(`üöÄ Starting production server on port ${port}...`);
  console.log(`   Bundle: ${ssrPath}`);
  console.log(`   Press Ctrl+C to stop`);
  console.log("");

  try {
    await import(ssrPath);
  } catch (error: any) {
    console.error("‚ùå Error starting production server:");
    console.error(error.message);
    process.exit(1);
  }
}

// ==================== CLI ROUTER ====================
const command = process.argv[2];

switch (command) {
  case "dev":
    await dev();
    break;
  case "build":
    await build();
    break;
  case "start":
    await start();
    break;
  default:
    console.error("Unknown command. Available commands: dev, build, start");
    process.exit(1);
}
